一、系统调用

1、系统调用是用户空间程序访问内核空间的一种方式，系统调用通过软中断0x80陷入内核，跳转到系统调用处理程序（中断处理程序）system_call函数，
     并执行相应的服务例程（内核函数）；比如系统调用dup()的服务例程是内核函数sys_dup()。

2、x86-32架构下分析dup()为例


![image](https://github.com/wanglinhuiyong/linux/blob/master/hook-syscall/image.png)

（1）	用户应用程序在某些时候可以直接通过系统调用来访问内核；但更多时候， 应用程序是通过操作系统提供的应用编程接口（API——C库的函数）而不是直接通过系统调用来编程。

（2）	内核提供的每个系统调用在C库中都具有相应的封装函数。系统调用与其C库封装函数的名称常常相同，比如，read系统调用在C库中的封装函数即为read函数。当然，也会有挺多C库封装函数和系统调用名称不同。

（3）	系统调用和C库函数之间并不是一一对应的关系。可能几个不同的函数会调用到同一个系统调用，即多对一关系，比如C库函数malloc和free都是通过brk系统调用来扩大或缩小进程的堆栈，execl、execlp、execle、execv、execvp和execve这些C库函数都是通过execve系统调用来执行一个可执行文件。也有可能一个函数调用多个系统调用，即一对多关系。

（4）	strace工具可以跟踪命令的执行，并显示出该命令执行过程中所使用到的所有系统调用。


